<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>.net dotnet testing mock moq on Adam Rodger</title><link>https://adamrodger.github.io/tags/.net-dotnet-testing-mock-moq/</link><description>Recent content in .net dotnet testing mock moq on Adam Rodger</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 25 Oct 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://adamrodger.github.io/tags/.net-dotnet-testing-mock-moq/index.xml" rel="self" type="application/rss+xml"/><item><title>Unit Testing with Mocks</title><link>https://adamrodger.github.io/post/2018-10-25-unit-testing-with-mocks/</link><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><guid>https://adamrodger.github.io/post/2018-10-25-unit-testing-with-mocks/</guid><description>When unit testing classes that have followed SOLID principles, we often find classes take on the responsibility of a co-ordinator rather than implementing any specific logic themselves. When testing these classes it makes perfect sense to use mocks (e.g. the Moq library) to control the dependencies being co-ordinated. However, I sometimes see instances where people have misunderstood how these mocks work and why the test ends up not testing what it appears to.</description></item></channel></rss>